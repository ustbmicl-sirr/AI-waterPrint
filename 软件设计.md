# 屏内数字水印溯源系统 - 软件设计文档
---
title: 屏内数字水印溯源系统 - 软件设计文档
version: 1.0.0
date: 2025-10-19
author: AI-waterPrint Team
---



## 一、系统架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户显示设备                              │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  应用程序 / 桌面环境                                      │  │
│  └────────────────────┬─────────────────────────────────────┘  │
│                       │                                         │
│  ┌────────────────────▼─────────────────────────────────────┐  │
│  │  系统合成器 (Compositor)                                 │  │
│  │  - Windows: DirectComposition / DXGI                     │  │
│  │  - macOS: CoreAnimation / Metal                          │  │
│  │  - Linux: X11 / Wayland                                  │  │
│  └────────────────────┬─────────────────────────────────────┘  │
│                       │                                         │
│  ┌────────────────────▼─────────────────────────────────────┐  │
│  │  端侧叠加服务 (Overlay Service)                          │  │
│  │  ├─ 水印生成引擎                                         │  │
│  │  ├─ GPU 渲染管理                                         │  │
│  │  ├─ 多屏管理                                             │  │
│  │  └─ 策略控制                                             │  │
│  └────────────────────┬─────────────────────────────────────┘  │
│                       │                                         │
│  ┌────────────────────▼─────────────────────────────────────┐  │
│  │  显示输出（含水印）                                      │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                    翻拍/录屏/截图
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    检测解码系统                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Detect SDK (C++ 核心)                                   │  │
│  │  ├─ 预处理与几何校正                                     │  │
│  │  ├─ 频域变换与同步                                       │  │
│  │  ├─ 软判决解码                                           │  │
│  │  ├─ 纠错与解密                                           │  │
│  │  └─ 置信度评估                                           │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  CLI 工具 / REST 服务                                    │  │
│  │  ├─ wm-detect (本地检测)                                 │  │
│  │  ├─ /v1/detect (同步/异步检测)                           │  │
│  │  └─ /v1/detections (查询结果)                            │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    服务端管理系统                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  设备与会话管理                                          │  │
│  │  ├─ /v1/devices/enroll (设备注册)                        │  │
│  │  ├─ /v1/devices/{id} (设备查询/更新)                     │  │
│  │  ├─ /v1/sessions (会话创建/查询)                         │  │
│  │  └─ /v1/reports (溯源报告)                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  密钥管理系统 (KMS)                                      │  │
│  │  ├─ 主密钥存储                                           │  │
│  │  ├─ 设备派生密钥                                         │  │
│  │  ├─ 会话短期密钥                                         │  │
│  │  └─ 密钥轮换与吊销                                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  数据存储与审计                                          │  │
│  │  ├─ 设备档案库                                           │  │
│  │  ├─ 检测记录库                                           │  │
│  │  ├─ 审计日志                                             │  │
│  │  └─ 溯源报告库                                           │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 分层架构

```
┌─────────────────────────────────────────────────────────┐
│  表现层 (Presentation Layer)                            │
│  - Web UI / CLI / REST API                              │
└─────────────────────────────────────────────────────────┘
                          │
┌─────────────────────────────────────────────────────────┐
│  业务逻辑层 (Business Logic Layer)                      │
│  - 水印生成与嵌入                                       │
│  - 检测与解码                                           │
│  - 设备与会话管理                                       │
│  - 溯源与报告生成                                       │
└─────────────────────────────────────────────────────────┘
                          │
┌─────────────────────────────────────────────────────────┐
│  算法层 (Algorithm Layer)                               │
│  - DWT/DCT 变换                                         │
│  - QIM 量化                                             │
│  - 同步模板检测                                         │
│  - 几何校正                                             │
│  - BCH/RS 纠错                                          │
└─────────────────────────────────────────────────────────┘
                          │
┌─────────────────────────────────────────────────────────┐
│  基础设施层 (Infrastructure Layer)                      │
│  - GPU 渲染                                             │
│  - 密码学库 (AES-GCM, HMAC)                             │
│  - 图像处理库                                           │
│  - 数据库                                               │
│  - 消息队列                                             │
└─────────────────────────────────────────────────────────┘
```

## 二、核心模块设计

### 2.1 端侧叠加模块 (Overlay Service)

#### 2.1.1 模块职责

- 生成水印载荷（设备ID + 会话ID + 时间戳）
- 对载荷进行加密与纠错编码
- 将水印嵌入到频域（DWT+DCT+QIM）
- 生成空域掩模并通过 GPU 叠加到桌面
- 管理多屏、HDR、策略等

#### 2.1.2 关键组件

```
OverlayService
├─ PayloadGenerator
│  ├─ device_id
│  ├─ session_id
│  ├─ timestamp
│  └─ nonce
├─ CryptoEngine
│  ├─ AES-GCM 加密
│  ├─ HMAC 签名
│  └─ 密钥管理
├─ ECC Encoder
│  ├─ BCH 编码
│  └─ RS 编码
├─ WatermarkEmbedder
│  ├─ DWT 变换
│  ├─ DCT 分块
│  ├─ QIM 量化
│  ├─ 同步模板生成
│  └─ 多尺度平铺
├─ JNDController
│  ├─ 局部对比度分析
│  ├─ 纹理能量计算
│  └─ 自适应强度调整
├─ GPURenderer
│  ├─ Shader 编译
│  ├─ 纹理管理
│  └─ 合成管理
└─ MultiScreenManager
   ├─ EDID 读取
   ├─ 坐标系管理
   └─ 独立掩模生成
```

#### 2.1.3 数据流

```
设备ID + 会话ID + 时间戳
        │
        ▼
┌──────────────────┐
│ PayloadGenerator │ → payload (96-128 bits)
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  CryptoEngine    │ → encrypted_payload + signature
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  ECC Encoder     │ → encoded_bits (with redundancy)
└──────────────────┘
        │
        ▼
┌──────────────────┐
│ WatermarkEmbedder│ → frequency_mask
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  JNDController   │ → adaptive_mask
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  GPURenderer     │ → spatial_overlay
└──────────────────┘
        │
        ▼
    屏幕显示
```

### 2.2 检测解码模块 (Detect SDK)

#### 2.2.1 模块职责

- 预处理输入图片/视频
- 估计与校正几何畸变
- 频域变换与同步定位
- 软判决解码与多帧融合
- 纠错、解密、验签
- 置信度评估与攻击类型识别

#### 2.2.2 关键组件

```
Detector
├─ Preprocessor
│  ├─ 边缘检测
│  ├─ 屏幕区域提取
│  └─ 色彩空间转换
├─ GeometryCorrector
│  ├─ 角点检测
│  ├─ 单应性估计
│  ├─ 透视变换
│  └─ 旋转/缩放校正
├─ FrequencyAnalyzer
│  ├─ DWT 变换
│  ├─ DCT 分块
│  ├─ 频谱分析
│  └─ 格栅峰值检测
├─ SyncLocator
│  ├─ 旋转角估计
│  ├─ 尺度估计
│  └─ Log-polar 搜索
├─ SoftDecoder
│  ├─ QIM 软判决
│  ├─ 多块投票
│  ├─ 多尺度融合
│  └─ 多帧融合
├─ ErrorCorrector
│  ├─ BCH 纠错
│  └─ RS 纠错
├─ CryptoVerifier
│  ├─ AES-GCM 解密
│  └─ HMAC 验证
└─ ConfidenceEstimator
   ├─ 比特可靠性评分
   ├─ 攻击类型识别
   └─ 综合置信度计算
```

#### 2.2.3 数据流

```
输入图片/视频
        │
        ▼
┌──────────────────┐
│  Preprocessor    │ → normalized_image
└──────────────────┘
        │
        ▼
┌──────────────────┐
│ GeometryCorrector│ → corrected_image + homography
└──────────────────┘
        │
        ▼
┌──────────────────┐
│FrequencyAnalyzer │ → frequency_domain
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  SyncLocator     │ → rotation + scale
└──────────────────┘
        │
        ▼
┌──────────────────┐
│  SoftDecoder     │ → soft_bits
└──────────────────┘
        │
        ▼
┌──────────────────┐
│ ErrorCorrector   │ → corrected_bits
└──────────────────┘
        │
        ▼
┌──────────────────┐
│ CryptoVerifier   │ → payload + signature_valid
└──────────────────┘
        │
        ▼
┌──────────────────┐
│ConfidenceEstimator│ → score + attack_hint
└──────────────────┘
        │
        ▼
    DetectionResult
```

### 2.3 服务端管理模块

#### 2.3.1 模块职责

- 设备注册与档案管理
- 会话创建与密钥下发
- 检测结果存储与查询
- 溯源报告生成与签名
- 审计日志与链路追踪
- 密钥轮换与吊销

#### 2.3.2 关键组件

```
ManagementService
├─ DeviceManager
│  ├─ 设备注册
│  ├─ 档案查询/更新
│  ├─ 状态管理
│  └─ 元数据存储
├─ SessionManager
│  ├─ 会话创建
│  ├─ 短期密钥生成
│  ├─ TTL 管理
│  └─ 会话查询
├─ KeyManagementSystem (KMS)
│  ├─ 主密钥存储
│  ├─ 派生密钥生成
│  ├─ 密钥轮换
│  ├─ 密钥吊销
│  └─ 版本管理
├─ DetectionRecorder
│  ├─ 结果存储
│  ├─ 索引管理
│  ├─ 查询接口
│  └─ 数据清理
├─ ReportGenerator
│  ├─ 报告生成
│  ├─ 数字签名
│  ├─ 存证
│  └─ 报告查询
└─ AuditLogger
   ├─ 操作日志
   ├─ 链路追踪
   ├─ 告警管理
   └─ 日志查询
```

## 三、水印算法设计

### 3.1 载荷结构

```
总长度：96-128 bits

┌──────┬────────┬───────┬──────────────┬──────────────┬───────┬─────┐
│ ver  │ vendor │ model │  device_id   │ session_ts   │ nonce │ crc │
│ 4bit │ 12bit  │ 12bit │  32/48 bit   │   32 bit     │16 bit │8bit │
└──────┴────────┴───────┴──────────────┴──────────────┴───────┴─────┘

加密与签名：
  payload_enc = AES-GCM(k_device, payload || aad)
  signature = HMAC-SHA256(payload_enc)
```

### 3.2 嵌入算法

```
1. 载荷编码
   payload → ECC_Encode(BCH/RS) → encoded_bits

2. 频域变换
   image → DWT(2-level) → LH/HL 子带

3. 分块 DCT
   for each 8×8 block in LH/HL:
     block → DCT → C

4. QIM 量化
   for each bit in encoded_bits:
     C_midfreq → QIM_Modulate(bit) → C'

5. 同步模板
   sync_template = sinusoidal_grid(freq1, dir1) + sinusoidal_grid(freq2, dir2)

6. 多尺度平铺
   for scale in [64×64, 128×128]:
     tile_mask += embed_at_scale(scale)

7. JND 自适应
   local_contrast = compute_local_contrast(screen_snapshot)
   adaptive_mask = JND_Modulate(mask, local_contrast)

8. 蓝噪声抖动
   final_overlay = BlueNoiseDither(adaptive_mask, alpha_base)

9. GPU 叠加
   CompositeToDesktop(final_overlay)
```

### 3.3 解码算法

```
1. 预处理
   image → edge_detect → screen_region_extract → normalize

2. 几何校正
   corners = detect_corners(image)
   H = estimate_homography(corners)
   corrected_image = warp(image, H^-1)

3. 频域变换
   corrected_image → DWT(2-level) → LH/HL 子带
   for each 8×8 block:
     block → DCT → C

4. 同步定位
   spectrum = FFT(C_midfreq)
   peaks = find_peaks(spectrum)
   rotation = estimate_rotation(peaks)
   scale = estimate_scale(peaks)

5. 软判决解码
   for each bit position:
     soft_value = aggregate_qim_decisions(C_midfreq, bit_position)
     soft_bits.append(soft_value)

6. 多帧融合（视频）
   for each frame:
     soft_bits_frame = decode_frame(frame)
     soft_bits_all.append(soft_bits_frame)
   soft_bits_final = weighted_average(soft_bits_all)

7. 纠错
   corrected_bits = BCH_Decode(soft_bits_final)

8. 解密与验证
   payload_enc = bits_to_bytes(corrected_bits)
   payload = AES_GCM_Decrypt(payload_enc, k_device)
   verify(HMAC_SHA256(payload_enc)) ? SUCCESS : FAIL

9. 置信度评估
   score = compute_confidence(soft_bits, corrected_bits, payload)
   attack_hint = identify_attacks(score, spectrum, geometry)
```

## 四、接口设计

### 4.1 端侧 SDK 接口 (C++)

```cpp
// 叠加服务
class OverlayService {
public:
  static OverlayService* Create(const WmConfig& cfg);
  bool Start();
  void SetPolicy(const Policy& p);
  void Stop();
  ~OverlayService();
};

// 检测服务
class Detector {
public:
  bool LoadKeyset(const Keyset& k);
  DetectResult FromImage(const Image& img);
  DetectResult FromVideo(const Video& vid, int max_frames=60);
};

// 数据结构
struct DetectResult {
  bool found;
  std::string device_id;
  uint64_t session_ts;
  double score;
  std::string attack_hint;
};
```

### 4.2 REST API 接口

详见软件需求文档第三部分的 OpenAPI 3.1 规范

主要端点：
- `POST /v1/detect` - 检测图片/视频
- `GET /v1/detections/{id}` - 查询检测结果
- `POST /v1/devices/enroll` - 设备注册
- `GET /v1/devices/{device_id}` - 查询设备
- `POST /v1/sessions` - 创建会话
- `POST /v1/reports` - 生成报告

## 五、数据存储设计

### 5.1 数据库模式

```sql
-- 设备表
CREATE TABLE devices (
  device_id VARCHAR(64) PRIMARY KEY,
  vendor VARCHAR(64),
  model VARCHAR(64),
  serial_number VARCHAR(128),
  status ENUM('active', 'suspended', 'revoked'),
  key_id VARCHAR(64),
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  metadata JSON
);

-- 会话表


## 十一、详细模块设计

### 11.1 PayloadGenerator 模块

**职责**：生成水印载荷

**输入**：
- device_id: 设备唯一标识
- session_id: 会话标识
- timestamp: 当前时间戳
- nonce: 随机数

**输出**：
- payload: 96-128 bits 的二进制数据

**算法**：
```
1. 验证输入参数
2. 组装载荷字段
   - ver (4 bits): 版本号
   - vendor (12 bits): 厂商编码
   - model (12 bits): 型号编码
   - device_id (32/48 bits): 设备ID
   - session_ts (32 bits): 时间戳
   - nonce (16 bits): 随机数
   - crc (8 bits): CRC 校验
3. 计算 CRC 校验码
4. 返回 payload
```

**关键参数**：
- 版本号：用于算法升级兼容
- CRC 校验：快速帧内校验

### 11.2 CryptoEngine 模块

**职责**：加密、签名、密钥管理

**主要接口**：
```cpp
class CryptoEngine {
public:
  // 加密
  std::vector<uint8_t> Encrypt(
    const std::vector<uint8_t>& plaintext,
    const std::string& key_id);

  // 解密
  std::vector<uint8_t> Decrypt(
    const std::vector<uint8_t>& ciphertext,
    const std::string& key_id);

  // 签名
  std::vector<uint8_t> Sign(
    const std::vector<uint8_t>& data,
    const std::string& key_id);

  // 验证签名
  bool Verify(
    const std::vector<uint8_t>& data,
    const std::vector<uint8_t>& signature,
    const std::string& key_id);
};
```

**加密方案**：
- 算法：AES-256-GCM
- 密钥长度：256 bits
- IV 长度：96 bits（随机生成）
- 认证标签长度：128 bits

**签名方案**：
- 算法：HMAC-SHA256
- 密钥长度：256 bits

### 11.3 WatermarkEmbedder 模块

**职责**：频域水印嵌入

**关键参数**：
```cpp
struct EmbedConfig {
  int dwt_levels = 2;           // DWT 分解级数
  int dct_block_size = 8;       // DCT 块大小
  float qim_delta = 0.5;        // QIM 量化步长
  int sync_freq1 = 32;          // 同步模板频率1
  int sync_freq2 = 48;          // 同步模板频率2
  std::vector<int> scales = {64, 128};  // 平铺尺度
};
```

**嵌入流程**：
```
1. DWT 分解（2 级）
   - 获得 LL, LH, HL, HH 子带
   - 使用 LH 和 HL 子带

2. 分块 DCT
   - 将 LH/HL 分成 8×8 块
   - 对每块进行 DCT 变换

3. QIM 量化
   - 对中频系数进行双阱量化
   - 根据比特值选择量化阱

4. 同步模板
   - 生成两组正弦格栅
   - 不同方向和频率
   - 用于旋转/缩放估计

5. 多尺度平铺
   - 在 64×64 和 128×128 尺度上重复嵌入
   - 提升裁剪鲁棒性

6. 逆变换
   - IDCT 变换
   - IDWT 重构
   - 得到频域掩模

7. JND 自适应
   - 计算局部对比度
   - 调整嵌入强度

8. 蓝噪声抖动
   - 在纯色区域引入随机抖动
   - 掩蔽水印纹理
```

### 11.4 GeometryCorrector 模块

**职责**：几何畸变校正

**输入**：
- 翻拍图像
- 可选的初始估计

**输出**：
- 校正后的图像
- 单应矩阵 H

**算法**：
```
1. 边缘检测
   - Canny 边缘检测
   - 获得屏幕边界

2. 角点检测
   - Harris 角点检测
   - 或 SIFT/SURF 特征点

3. 单应性估计
   - 使用 RANSAC 算法
   - 估计 3×3 单应矩阵

4. 透视变换
   - 使用 H 矩阵进行仿射变换
   - 得到校正图像

5. 质量评估
   - 计算变换误差
   - 评估校正质量
```

**关键参数**：
- RANSAC 迭代次数：1000
- 内点阈值：3.0 像素
- 最小内点数：4

### 11.5 SyncLocator 模块

**职责**：同步模板定位与几何参数估计

**输入**：
- 频域数据（DCT 系数）
- 同步模板参数

**输出**：
- 旋转角 θ
- 缩放因子 s

**算法**：
```
1. 频谱分析
   - 对中频系数进行 FFT
   - 获得频谱

2. 峰值检测
   - 检测同步模板的峰值
   - 两组格栅对应的峰值

3. 旋转角估计
   - 根据峰值方向估计旋转
   - 使用 atan2 计算角度

4. 尺度估计
   - 根据峰值频率估计缩放
   - 使用 log-polar 坐标

5. 精细调整
   - 使用 Log-polar 搜索
   - 微调旋转和缩放参数
```

### 11.6 SoftDecoder 模块

**职责**：软判决解码与多帧融合

**输入**：
- 频域数据（DCT 系数）
- 同步参数（旋转、缩放）
- 多帧数据（视频）

**输出**：
- 软比特序列 soft_bits
- 每比特的可靠性评分

**算法**：
```
1. 单帧解码
   for each bit position:
     soft_value = 0
     for each scale in scales:
       for each tile in tiles[scale]:
         qim_value = extract_qim_value(tile, bit_position)
         soft_value += qim_value
     soft_bits[bit_position] = soft_value / num_tiles

2. 多帧融合（视频）
   for each frame:
     soft_bits_frame = decode_frame(frame)
     soft_bits_all.append(soft_bits_frame)

   soft_bits_final = weighted_average(soft_bits_all)
   weights = compute_frame_weights(soft_bits_all)

3. 可靠性评分
   for each bit:
     reliability = abs(soft_bits[bit]) / max_value
     confidence_scores[bit] = reliability
```

### 11.7 ErrorCorrector 模块

**职责**：纠错编码与解码

**支持的编码**：
- BCH(127, k)：用于短码
- RS(255, k)：用于长码

**参数配置**：
```cpp
struct ECCConfig {
  std::string code_type;  // "BCH" 或 "RS"
  int n;                  // 码长
  int k;                  // 信息位长
  int t;                  // 纠错能力
};
```

**解码流程**：
```
1. 软判决输入
   - 接收软比特序列
   - 每比特的可靠性评分

2. 硬判决
   - 根据阈值转换为硬比特
   - 或使用软判决算法

3. 纠错解码
   - BCH：使用 Berlekamp-Massey 算法
   - RS：使用 Euclidean 算法

4. 错误定位与纠正
   - 定位错误位置
   - 计算错误值
   - 纠正错误

5. 验证
   - 检查校验码
   - 确认纠错成功
```

### 11.8 ConfidenceEstimator 模块

**职责**：置信度评估与攻击类型识别

**输出**：
```cpp
struct ConfidenceResult {
  double overall_score;      // 0-1，总体置信度
  double bit_reliability;    // 比特可靠性
  double sync_quality;       // 同步质量
  std::string attack_hint;   // 攻击类型提示
  double jpeg_quality;       // JPEG 质量估计
  double blur_level;         // 模糊程度
  double perspective_angle;  // 透视角度
};
```

**评估方法**：
```
1. 比特可靠性
   bit_reliability = avg(abs(soft_bits))

2. 同步质量
   sync_quality = peak_height / noise_floor

3. 纠错成功率
   ecc_success = (errors_corrected <= t) ? 1.0 : 0.0

4. 综合置信度
   overall_score =
     0.4 * bit_reliability +
     0.3 * sync_quality +
     0.3 * ecc_success

5. 攻击类型识别
   if jpeg_artifacts_detected:
     attack_hint += "jpeg"
   if blur_detected:
     attack_hint += "blur"
   if perspective_distortion:
     attack_hint += "perspective"
```



## 十二、工作流程设计

### 12.1 端侧叠加工作流程

```
启动 OverlayService
    │
    ├─ 读取设备配置（device_id, endpoint）
    ├─ 连接 KMS 获取主密钥
    ├─ 初始化 GPU 渲染环境
    └─ 进入主循环
        │
        ├─ 每帧循环（60 FPS）
        │   ├─ 获取当前会话信息
        │   ├─ 生成载荷（device_id + session_id + timestamp）
        │   ├─ 加密与签名
        │   ├─ ECC 编码
        │   ├─ 频域嵌入（DWT+DCT+QIM）
        │   ├─ 同步模板合成
        │   ├─ 多尺度平铺
        │   ├─ JND 自适应强度调整
        │   ├─ 蓝噪声抖动
        │   ├─ GPU 渲染掩模
        │   └─ 合成到桌面
        │
        ├─ 监听系统事件
        │   ├─ 显示器热插拔
        │   ├─ 分辨率变化
        │   ├─ HDR 模式切换
        │   └─ 应用全屏切换
        │
        └─ 定期任务
            ├─ 密钥轮换检查
            ├─ 性能监控
            ├─ 日志上传
            └─ 策略更新
```

### 12.2 检测解码工作流程

```
输入：图片或视频
    │
    ├─ 预处理
    │   ├─ 色彩空间转换（RGB/YUV）
    │   ├─ 归一化
    │   └─ 边缘检测
    │
    ├─ 几何校正
    │   ├─ 屏幕区域提取
    │   ├─ 角点检测
    │   ├─ 单应性估计（RANSAC）
    │   └─ 透视变换
    │
    ├─ 频域分析
    │   ├─ DWT 分解（2 级）
    │   ├─ DCT 分块
    │   ├─ 频谱分析
    │   └─ 格栅峰值检测
    │
    ├─ 同步定位
    │   ├─ 旋转角估计
    │   ├─ 尺度估计
    │   └─ Log-polar 精细调整
    │
    ├─ 软判决解码
    │   ├─ QIM 软判决
    │   ├─ 多块投票
    │   ├─ 多尺度融合
    │   └─ 多帧融合（视频）
    │
    ├─ 纠错解密
    │   ├─ BCH/RS 纠错
    │   ├─ AES-GCM 解密
    │   └─ HMAC 验证
    │
    ├─ 置信度评估
    │   ├─ 比特可靠性
    │   ├─ 同步质量
    │   ├─ 攻击类型识别
    │   └─ 综合评分
    │
    └─ 输出：DetectionResult
        ├─ found: 是否检测到水印
        ├─ device_id: 设备标识
        ├─ session_ts: 时间戳
        ├─ score: 置信度 (0-1)
        ├─ attack_hint: 攻击类型
        └─ evidence: 取证信息
```

### 12.3 服务端溯源工作流程

```
接收检测结果
    │
    ├─ 验证请求签名
    ├─ 查询设备档案
    ├─ 验证会话有效性
    ├─ 查询密钥版本
    │
    ├─ 生成溯源报告
    │   ├─ 关联设备信息
    │   ├─ 关联会话信息
    │   ├─ 计算时间戳
    │   ├─ 收集取证信息
    │   └─ 生成报告摘要
    │
    ├─ 数字签名
    │   ├─ 使用 CA 私钥签名
    │   ├─ 生成签名证书
    │   └─ 时间戳认证
    │
    ├─ 存储与审计
    │   ├─ 保存检测记录
    │   ├─ 保存报告
    │   ├─ 记录审计日志
    │   └─ 上传到审计系统
    │
    └─ 返回报告
        ├─ report_id
        ├─ device_id
        ├─ signature
        ├─ timestamp
        └─ evidence
```

## 十三、集成指南

### 13.1 端侧集成

#### Windows 集成

```cpp
// 1. 初始化
WmConfig config;
config.device_id = "ACME-24F-00112233";
config.endpoint = "https://kms.example.com";
config.adaptive_strength = true;
config.alpha_base = 0.3;

OverlayService* service = OverlayService::Create(config);

// 2. 启动
if (!service->Start()) {
  LOG(ERROR) << "Failed to start overlay service";
  return false;
}

// 3. 设置策略
Policy policy;
policy.blacklist_apps = {"game.exe", "player.exe"};
policy.hdr_mode = true;
service->SetPolicy(policy);

// 4. 运行
// 服务在后台运行，定期更新水印

// 5. 停止
service->Stop();
delete service;
```

#### macOS 集成

```cpp
// 使用 CoreAnimation 和 Metal
// 类似 Windows 集成，但使用 macOS 特定的 API
```

#### Linux 集成

```cpp
// 支持 X11 和 Wayland
// X11：使用 XComposite 扩展
// Wayland：使用 wl-layer-shell 协议
```

### 13.2 检测端集成

#### C++ SDK 集成

```cpp
#include "watermark/detector.h"

// 1. 初始化
Detector detector;
Keyset keyset;
keyset.LoadFromFile("keys.bin");
detector.LoadKeyset(keyset);

// 2. 检测图片
Image img;
img.LoadFromFile("photo.jpg");
DetectResult result = detector.FromImage(img);

if (result.found) {
  std::cout << "Device: " << result.device_id << std::endl;
  std::cout << "Score: " << result.score << std::endl;
  std::cout << "Attack: " << result.attack_hint << std::endl;
}

// 3. 检测视频
Video vid;
vid.LoadFromFile("video.mp4");
DetectResult result = detector.FromVideo(vid, 60);
```

#### REST API 集成

```bash
# 检测图片
curl -X POST 'https://api.example.com/v1/detect?async=false' \
  -H 'X-API-Key: YOUR_API_KEY' \
  -F 'file=@photo.jpg' \
  -F 'return_payload=true'

# 异步检测视频
curl -X POST 'https://api.example.com/v1/detect?async=true&max_frames=60' \
  -H 'Authorization: Bearer YOUR_JWT' \
  -F 'file=@video.mp4'

# 查询结果
curl -X GET 'https://api.example.com/v1/detections/det_01HV6Z4W7M...' \
  -H 'Authorization: Bearer YOUR_JWT'
```

### 13.3 服务端集成

#### 设备注册

```bash
curl -X POST 'https://api.example.com/v1/devices/enroll' \
  -H 'X-API-Key: YOUR_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "device_id": "ACME-24F-00112233",
    "vendor": "ACME",
    "model": "X24U",
    "serial_number": "SN123456",
    "metadata": {
      "location": "Office-A-101",
      "owner": "user@example.com"
    }
  }'
```

#### 会话创建

```bash
curl -X POST 'https://api.example.com/v1/sessions' \
  -H 'Authorization: Bearer YOUR_JWT' \
  -H 'Content-Type: application/json' \
  -d '{
    "device_id": "ACME-24F-00112233",
    "ttl_seconds": 3600,
    "purpose": "overlay-runtime"
  }'
```

#### 报告生成

```bash
curl -X POST 'https://api.example.com/v1/reports' \
  -H 'Authorization: Bearer YOUR_JWT' \
  -H 'Content-Type: application/json' \
  -d '{
    "detection_id": "det_01HV6Z4W7M...",
    "reviewer": "security.officer@example.com",
    "notes": "与员工 A 的工位显示器匹配"
  }'
```

## 十四、配置与参数

### 14.1 端侧配置

```yaml
# overlay_config.yaml
device:
  id: "ACME-24F-00112233"
  vendor: "ACME"
  model: "X24U"

kms:
  endpoint: "https://kms.example.com"
  timeout: 30

watermark:
  adaptive_strength: true
  alpha_base: 0.3
  dwt_levels: 2
  dct_block_size: 8
  qim_delta: 0.5
  scales: [64, 128]

jnd:
  enabled: true
  contrast_threshold: 0.1

blue_noise:
  enabled: true
  strength: 0.5

policy:
  blacklist_apps:
    - "game.exe"
    - "player.exe"
  hdr_mode: true
  multi_screen: true

logging:
  level: "INFO"
  file: "/var/log/watermark/overlay.log"
  max_size: "100MB"
  retention: 30
```

### 14.2 检测端配置

```yaml
# detector_config.yaml
algorithm:
  dwt_levels: 2
  dct_block_size: 8
  sync_freq1: 32
  sync_freq2: 48
  scales: [64, 128]

geometry:
  ransac_iterations: 1000
  inlier_threshold: 3.0
  min_inliers: 4

sync:
  log_polar_search: true
  search_range: 5

decoder:
  soft_decision: true
  multi_frame_fusion: true
  frame_weights: "adaptive"

ecc:
  code_type: "RS"
  n: 255
  k: 200
  t: 27

confidence:
  bit_reliability_weight: 0.4
  sync_quality_weight: 0.3
  ecc_success_weight: 0.3
  threshold: 0.8

logging:
  level: "INFO"
  file: "/var/log/watermark/detector.log"
```

## 十五、故障处理与恢复

### 15.1 端侧故障处理

| 故障 | 症状 | 恢复方案 |
|------|------|--------|
| GPU 初始化失败 | 无法启动叠加 | 降级到 CPU 渲染或禁用水印 |
| 密钥获取失败 | 无法加密载荷 | 使用缓存的短期密钥 |
| 显示器热插拔 | 新屏幕无水印 | 自动检测并重新初始化 |
| 内存泄漏 | 长时间运行崩溃 | 定期重启服务 |
| 网络断连 | 无法更新策略 | 使用本地缓存策略 |

### 15.2 检测端故障处理

| 故障 | 症状 | 恢复方案 |
|------|------|--------|
| 几何校正失败 | 无法定位屏幕 | 使用全图检测或手动指定区域 |
| 同步定位失败 | 无法估计旋转/缩放 | 尝试多个初始估计 |
| 纠错失败 | 无法恢复载荷 | 返回低置信度结果 |
| 内存不足 | 处理大视频失败 | 分帧处理或降低分辨率 |

### 15.3 服务端故障处理

| 故障 | 症状 | 恢复方案 |
|------|------|--------|
| 数据库连接失败 | API 返回 500 | 使用只读副本或缓存 |
| KMS 不可用 | 无法签名报告 | 使用离线签名或延迟处理 |
| 消息队列满 | 异步任务堆积 | 增加消费者或降低优先级 |
| 磁盘满 | 无法写入日志 | 清理旧日志或扩展存储 |

---

## 十六、总结

本设计文档详细阐述了屏内数字水印溯源系统的完整架构、核心模块、算法设计、接口规范、部署方案等内容。

### 关键设计特点

1. **系统级透明叠加**：无需应用集成，在 OS 合成阶段直接注入水印
2. **频域鲁棒嵌入**：DWT+DCT+QIM 组合，对常见翻拍工况具有强鲁棒性
3. **盲检测能力**：无需原图，仅从翻拍图像恢复水印信息
4. **多层次安全**：密钥管理、加密签名、审计日志、访问控制
5. **跨平台支持**：Windows/macOS/Linux，多屏、HDR、不同分辨率
6. **完整溯源链**：从端侧叠加到检测解码再到服务端报告，形成闭环

### 后续工作

- 原型实现与算法验证
- 性能优化与鲁棒性测试
- 跨平台适配与兼容性测试
- 安全审计与合规评估
- 规模化部署与运维支持

